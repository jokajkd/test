-- Username Hiding System
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local fakeName = "GameChanger"

-- Function to hide username in GUIs
local function hideUsernameInGUIs()
    -- Monitor PlayerGui for new GUI elements
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    local function updateTextElements(parent)
        for _, gui in pairs(parent:GetDescendants()) do
            if gui:IsA("TextLabel") or gui:IsA("TextButton") or gui:IsA("TextBox") then
                local text = gui.Text
                if text and type(text) == "string" then
                    -- Replace actual username with fake name
                    if text:find(LocalPlayer.Name) then
                        gui.Text = text:gsub(LocalPlayer.Name, fakeName)
                    end
                end
            end
        end
    end
    
    -- Update existing GUI elements
    updateTextElements(playerGui)
    
    -- Monitor for new GUI elements
    playerGui.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("TextLabel") or descendant:IsA("TextButton") or descendant:IsA("TextBox") then
            wait() -- Wait for properties to load
            local text = descendant.Text
            if text and type(text) == "string" then
                if text:find(LocalPlayer.Name) then
                    descendant.Text = text:gsub(LocalPlayer.Name, fakeName)
                end
            end
        end
    end)
end

-- Function to hide username in leaderboard and player list
local function hideUsernameInLeaderboard()
    -- Monitor CoreGui for leaderboard elements
    local coreGui = game:GetService("CoreGui")
    
    local function updateLeaderboardElements(parent)
        for _, gui in pairs(parent:GetDescendants()) do
            if gui:IsA("TextLabel") then
                local text = gui.Text
                if text and type(text) == "string" then
                    if text:find(LocalPlayer.Name) then
                        gui.Text = text:gsub(LocalPlayer.Name, fakeName)
                    end
                end
            end
        end
    end
    
    -- Update existing leaderboard elements
    updateLeaderboardElements(coreGui)
    
    -- Monitor for new leaderboard elements
    coreGui.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("TextLabel") then
            wait()
            local text = descendant.Text
            if text and type(text) == "string" then
                if text:find(LocalPlayer.Name) then
                    descendant.Text = text:gsub(LocalPlayer.Name, fakeName)
                end
            end
        end
    end)
end

-- Function to override player name property
local function overridePlayerName()
    -- Hook into the player's name property
    local mt = getrawmetatable(LocalPlayer)
    if mt then
        local oldIndex = mt.__index
        setreadonly(mt, false)
        
        mt.__index = function(t, k)
            if tostring(k) == "Name" or tostring(k) == "DisplayName" then
                return fakeName
            end
            return oldIndex(t, k)
        end
        setreadonly(mt, true)
    end
end

-- Function to hide username in chat
local function hideUsernameInChat()
    local TextChatService = game:GetService("TextChatService")
    
    if TextChatService then
        TextChatService.MessageReceived:Connect(function(message)
            if message.TextSource then
                local speaker = message.TextSource
                if speaker.Name == LocalPlayer.Name then
                    -- This would require more advanced chat manipulation
                    -- which may not be possible in all games
                end
            end
        end)
    end
end

-- Function to hide username above character (nametag)
local function hideNametag()
    LocalPlayer.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        
        -- Monitor for nametag changes
        humanoid:GetPropertyChangedSignal("DisplayName"):Connect(function()
            if humanoid.DisplayName == LocalPlayer.Name then
                humanoid.DisplayName = fakeName
            end
        end)
        
        -- Set initial nametag
        if humanoid.DisplayName == LocalPlayer.Name then
            humanoid.DisplayName = fakeName
        end
    end)
    
    -- Handle existing character
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid.DisplayName == LocalPlayer.Name then
            humanoid.DisplayName = fakeName
        end
    end
end

-- Initialize username hiding
print("üïµÔ∏è Initializing username hiding...")
pcall(hideUsernameInGUIs)
pcall(hideUsernameInLeaderboard)
pcall(overridePlayerName)
pcall(hideUsernameInChat)
pcall(hideNametag)
print("‚úÖ Username hidden! Showing as: " .. fakeName)

-- Check game place ID and run specific scripts
local placeId = game.PlaceId
print("üìç Current Place ID:", placeId)

if placeId == 80561320113856 then
    print("üéØ Running Sewers Zombie Attack Script...")
    
    -- Delete specified objects
    local success1, error1 = pcall(function()
        game:GetService("ReplicatedStorage").game_remotez.call_CONDITIONCHANGES:Destroy()
    end)

    local success2, error2 = pcall(function()
        game:GetService("ReplicatedStorage").ErrorReporter:Destroy()
    end)

    -- Print deletion results
    if success1 then
        print("Successfully deleted: game:GetService(\"ReplicatedStorage\").game_remotez.call_CONDITIONCHANGES")
    else
        print("Error deleting call_CONDITIONCHANGES:", error1)
    end

    if success2 then
        print("Successfully deleted: game:GetService(\"ReplicatedStorage\").ErrorReporter")
    else
        print("Error deleting ErrorReporter:", error2)
    end

    -- Run the firing script for Sewers map
    local args = {
        "Gun",
        game:GetService("Players").LocalPlayer.Character:WaitForChild("Dual Zeus"),
        workspace:WaitForChild("CURRENT_MAP"):WaitForChild("Sewers"):WaitForChild("Zombie"):WaitForChild("Head"),
        {
            {
                ChargeLevel = 0,
                ClientHitSize = Vector3.new(3.1703529357910156, 3.889321804046631, 3.8566854000091553),
                Distance = 36.665489196777344,
                ModuleName = "1",
                BulletId = "21,21|Bullet_{E6C22CEB-4569!2 C 3 F - A 3 D 0 - 8 E 5 B 0 6!.!, 9 E }"
            },
            {
                ChargeLevel = false,
                ClientHitSize = false,
                Distance = false,
                ModuleName = false,
                BulletId = true
            }
        }
    }

    local isFiring = true -- Changed to true for automatic firing
    local firingRate = 0.0000000000000000000000000000000000000001
    local shotsPerBurst = 100 -- Number of shots to fire per burst

    -- Function to check if zombie is dead or game is finished
    local function checkGameStatus()
        local currentMap = workspace:WaitForChild("CURRENT_MAP")
        local sewers = currentMap:WaitForChild("Sewers")
        local zombie = sewers:WaitForChild("Zombie")
        
        -- Check if zombie exists and has health
        if zombie:FindFirstChild("Humanoid") then
            local humanoid = zombie.Humanoid
            if humanoid.Health <= 0 then
                print("üéØ Zombie defeated! Teleporting to lobby...")
                return true
            end
        end
        
        -- Check if head exists (zombie might be dead if head is missing)
        if not zombie:FindFirstChild("Head") then
            print("üéØ Zombie head missing! Teleporting to lobby...")
            return true
        end
        
        -- Check for game completion signals (you might need to adjust this based on your game)
        local gameFinished = workspace:FindFirstChild("GameFinished") or 
                            workspace:FindFirstChild("LevelComplete") or
                            workspace:FindFirstChild("MissionComplete")
        
        if gameFinished then
            print("üéØ Game completed! Teleporting to lobby...")
            return true
        end
        
        return false
    end

    -- Function to teleport to the lobby
    local function teleportToLobby()
        local TeleportService = game:GetService("TeleportService")
        local targetPlaceId = 15899178400
        
        print("üöÄ Teleporting to lobby (place ID: " .. targetPlaceId .. ")")
        
        local success, errorMsg = pcall(function()
            TeleportService:Teleport(targetPlaceId)
        end)
        
        if not success then
            warn("‚ùå Teleport failed:", errorMsg)
            print("‚ö†Ô∏è  Please join place ID 15899178400 manually")
        end
    end

    -- Monitor game status
    local function startGameMonitor()
        while true do
            if checkGameStatus() then
                teleportToLobby()
                break
            end
            wait(1) -- Check every second
        end
    end

    local function startFiring()
        while isFiring do
            -- Fire multiple shots in quick succession
            for i = 1, shotsPerBurst do
                game:GetService("ReplicatedStorage").Remotes.InflictTarget:FireServer(unpack(args))
            end
            wait(firingRate)
        end
    end

    -- Start firing automatically
    spawn(startFiring)
    print("üî• Automatic firing started!")

    -- Start monitoring the game status
    spawn(startGameMonitor)

    print("Firing script loaded! Automatic rapid fire enabled.")
    print("Game monitor active - will auto-teleport to lobby when zombie is defeated!")

elseif placeId == 15899178400 then
    print("üéØ Running Party Creation Script...")
    
    -- Function to check if we're actually in a game (not stuck in lobby)
    local function verifyInGame()
        -- Check for game-specific objects that indicate we're in a match
        local gameIndicators = {
            workspace:FindFirstChild("CURRENT_MAP"),
            workspace:FindFirstChild("Zombie"),
            workspace:FindFirstChild("RoundSystem"),
            workspace:FindFirstChild("GameStarted")
        }
        
        for _, indicator in pairs(gameIndicators) do
            if indicator then
                return true
            end
        end
        
        -- Check if we're in the actual lobby (not in a game)
        local lobbyIndicators = {
            workspace:FindFirstChild("Lobby"),
            workspace:FindFirstChild("PartySystem"),
            workspace:FindFirstChild("StartGame")
        }
        
        for _, indicator in pairs(lobbyIndicators) do
            if indicator then
                return false -- We're in lobby, not in game
            end
        end
        
        return false -- Default to lobby if unsure
    end

    -- Enhanced party creation with verification
    local function createPartyWithVerification()
        local maxRetries = 5
        local retryDelay = 3
        
        for attempt = 1, maxRetries do
            print("üîÑ Attempt " .. attempt .. " to create party...")
            
            local success, errorMsg = pcall(function()
                local A_1 = "CREATE"
                local A_2 = {
                    ["RoomID"] = 302389339, 
                    ["Boss"] = "Infector", 
                    ["Limit"] = 4, 
                    ["Status"] = false, 
                    ["Password"] = "teah"
                }
                local Event = game:GetService("ReplicatedStorage").PartySystem
                Event:FireServer(A_1, A_2)
            end)
            
            if success then
                print("‚úÖ Party creation signal sent!")
                
                -- Wait and verify if we actually got into a game
                wait(5)
                
                if verifyInGame() then
                    print("üéâ Successfully entered the game!")
                    return true
                else
                    print("‚ö†Ô∏è Party created but still in lobby, retrying...")
                end
            else
                print("‚ùå Party creation failed (attempt " .. attempt .. "):", errorMsg)
            end
            
            if attempt < maxRetries then
                print("‚è≥ Retrying in " .. retryDelay .. " seconds...")
                wait(retryDelay)
            end
        end
        
        return false
    end

    -- Enhanced game start with verification
    local function startGameWithVerification()
        local maxRetries = 5
        local retryDelay = 3
        
        for attempt = 1, maxRetries do
            print("üîÑ Attempt " .. attempt .. " to start game...")
            
            local success, errorMsg = pcall(function()
                local args = {"START"}
                game:GetService("ReplicatedStorage"):WaitForChild("PartySystem"):FireServer(unpack(args))
            end)
            
            if success then
                print("‚úÖ Game start signal sent!")
                
                -- Wait and verify if game actually started
                wait(5)
                
                if verifyInGame() then
                    print("üéâ Game started successfully!")
                    return true
                else
                    print("‚ö†Ô∏è Start signal sent but still in lobby, retrying...")
                end
            else
                print("‚ùå Game start failed (attempt " .. attempt .. "):", errorMsg)
            end
            
            if attempt < maxRetries then
                print("‚è≥ Retrying in " .. retryDelay .. " seconds...")
                wait(retryDelay)
            end
        end
        
        return false
    end

    -- Alternative: Try different room IDs if current one fails
    local function tryDifferentRooms()
        local roomIDs = {302389339, 302389340, 302389341, 302389342}
        local bosses = {"Infector", "DeadLight", "Necromancer"}
        
        for _, roomId in pairs(roomIDs) do
            for _, boss in pairs(bosses) do
                print("üîÑ Trying Room ID: " .. roomId .. " with Boss: " .. boss)
                
                local success = pcall(function()
                    local A_1 = "CREATE"
                    local A_2 = {
                        ["RoomID"] = roomId, 
                        ["Boss"] = boss, 
                        ["Limit"] = 4, 
                        ["Status"] = false, 
                        ["Password"] = "teah"
                    }
                    game:GetService("ReplicatedStorage").PartySystem:FireServer(A_1, A_2)
                end)
                
                if success then
                    wait(5)
                    if verifyInGame() then
                        print("üéâ Success with Room " .. roomId .. " and Boss " .. boss)
                        return true
                    end
                end
                
                wait(2) -- Wait between attempts
            end
        end
        return false
    end

    -- Main execution with fallback options
    print("üöÄ Starting party creation process...")
    
    -- First try the standard method
    if createPartyWithVerification() then
        wait(2)
        if startGameWithVerification() then
            print("üéâ Party system completed successfully!")
        else
            print("‚ö†Ô∏è Party created but start failed, trying alternative methods...")
            tryDifferentRooms()
        end
    else
        print("‚ö†Ô∏è Standard party creation failed, trying alternative rooms...")
        if not tryDifferentRooms() then
            warn("‚ùå All party creation attempts failed!")
            print("üí° Possible solutions:")
            print("   - Wait for server to be less busy")
            print("   - Try a different room ID")
            print("   - Check if the game has updates")
        end
    end

else
    print("‚ùå No specific script for this game place ID:", placeId)
    print("‚ÑπÔ∏è  Supported Place IDs: 80561320113856 (Sewers Zombie Game) or 15899178400 (Party Lobby)")
end
